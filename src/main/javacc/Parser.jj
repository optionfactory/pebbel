options {
    STATIC = false;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(JavaccParser)
package net.optionfactory.pebbel.parsing;
import java.io.Serializable;
import net.optionfactory.pebbel.ast.BooleanExpression;
import net.optionfactory.pebbel.ast.BooleanOperator;
import net.optionfactory.pebbel.ast.Expression;
import net.optionfactory.pebbel.ast.FunctionCall;
import net.optionfactory.pebbel.ast.NumberExpression;
import net.optionfactory.pebbel.ast.NumberLiteral;
import net.optionfactory.pebbel.ast.ShortCircuitExpression;
import net.optionfactory.pebbel.ast.Source;
import net.optionfactory.pebbel.ast.StringExpression;
import net.optionfactory.pebbel.ast.StringLiteral;
import net.optionfactory.pebbel.ast.Variable;
import java.util.ArrayList;
import java.util.List;

public class JavaccParser {

    private Source source(Token t) {
        return Source.of(t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }

    private Source source(Source start, Source end) {
        return Source.of(start.row, start.col, end.endRow, end.endCol);
    }

    private Source source(Token l, Token r) {
        return Source.of(l.beginLine, l.beginColumn, r.endLine, r.endColumn);
    }


    public Expression parse(Class<?> expectedType) throws ParseException {
        if (expectedType == Boolean.class) {
            return terminalBooleanExpression();
        } 
        if (expectedType == String.class || expectedType == CharSequence.class) {
            return terminalStringExpression();
        } 
        if (expectedType == Double.class || expectedType == Number.class) {
            return terminalNumberExpression();
        } 
        if(expectedType == Object.class || expectedType == Serializable.class || expectedType == Comparable.class){
            return terminalAnyTypeExpression();
        }
        return terminalAnyOtherTypeExpression();
    }
}
PARSER_END(JavaccParser)


TOKEN_MGR_DECLS:
{
    private int lexerState;
}

<DEFAULT> TOKEN: {
      <VARIABLE: ["A"-"Z"](["A"-"Z","0"-"9","_", ":"])*>
    | <FUNCTION_NAME: ["a"-"z"](["a"-"z","A"-"Z","0"-"9","_", "?", "!", ":"])*>
    | <NUMBER: (["0"-"9"])+("." (["0"-"9"])*)?>
    | <L_PAREN: "(">
    | <R_PAREN: ")">
    | <AND: "&&" >
    | <OR: "||" >
    | <FUNCTION_ARGUMENT_SEPARATOR: "," >
    | <DOUBLE_QUOTE_STRING_LITERAL_START: "\""> { this.lexerState = curLexState; }: IN_DOUBLE_QUOTE_STRING_LITERAL
    | <SINGLE_QUOTE_STRING_LITERAL_START: "'"> { this.lexerState = curLexState; }: IN_SINGLE_QUOTE_STRING_LITERAL
}

<IN_DOUBLE_QUOTE_STRING_LITERAL> TOKEN: {
      <DOUBLE_QUOTE_STRING_LITERAL_END: "\""> { SwitchTo(this.lexerState); }
    | <DOUBLE_QUOTE_STRING_LITERAL: (~["\""]|"\\\"")+ > { matchedToken.image = matchedToken.image.replace("\\\"", "\""); }
}


<IN_SINGLE_QUOTE_STRING_LITERAL> TOKEN: {
      <SINGLE_QUOTE_STRING_LITERAL_END: "'"> { SwitchTo(this.lexerState); }
    | <SINGLE_QUOTE_STRING_LITERAL: (~["'"]|"\\'")+ > { matchedToken.image = matchedToken.image.replace("\\'", "'"); }
}



<DEFAULT> SKIP: {
    "\t"|" "|"\r"|"\n"
}

 <*> TOKEN : { 
    <UNKNOWN: ~[]> 
}

BooleanExpression terminalBooleanExpression():
{
    BooleanExpression result;
}
{
    result=booleanExpression() <EOF>
    { return result; }
}

StringExpression terminalStringExpression():
{
    StringExpression result;
}
{
    result=stringExpression() <EOF>
    { return result; }
}

NumberExpression terminalNumberExpression():
{
    NumberExpression result;
}
{
    result=numberExpression() <EOF>
    { return result; }
}

Expression terminalAnyTypeExpression():
{
    Expression result;
}
{
    (result=expression()) <EOF>
    { return result; }
}

Expression terminalAnyOtherTypeExpression():
{
    Expression result;
}
{
    (result=variable() | result=functionCall()) <EOF>
    { return result; }
}


BooleanExpression booleanExpression():
{
    BooleanExpression e;
}
{
    ( LOOKAHEAD(shortCircuitingBooleanExpression()) e=shortCircuitingBooleanExpression()| e=functionCall() | e=variable())
    { return e; }
}

BooleanExpression shortCircuitingBooleanExpression():
{
    Token op=null;
    BooleanExpression firstTerm=null, term=null;
    List<BooleanExpression> terms = new ArrayList<BooleanExpression>();
    List<BooleanOperator> operators = new ArrayList<BooleanOperator>();
}
{
        ( firstTerm=booleanExpressionTerm() {terms.add(firstTerm); })
        ( ( op=<AND>|op=<OR> ) term = booleanExpressionTerm() {operators.add(op.kind == AND ? BooleanOperator.AND : BooleanOperator.OR); terms.add(term); })+

    { if(operators.isEmpty()) return firstTerm; return ShortCircuitExpression.of(operators.toArray(new BooleanOperator[operators.size()]), terms.toArray(new BooleanExpression[terms.size()]), source(firstTerm.source(), terms != null ? term.source() : firstTerm.source()));  }
}

StringExpression stringExpression():
{ StringExpression e;}
{
    ( e=variable() | e=functionCall() | e=string() )
    { return e; }
}

NumberExpression numberExpression():
{ NumberExpression e;}
{
    ( e=variable() | e=number() | e=functionCall())
    { return e; }
}


FunctionCall functionCall():
{ Token ct,end; Expression e; List<Expression> es = new ArrayList<Expression>(); }
{
    ct=<FUNCTION_NAME>
    <L_PAREN>
        [
            e=expression() { es.add(e); }
            ( <FUNCTION_ARGUMENT_SEPARATOR> e=expression() { es.add(e); })*
        ]
    end=<R_PAREN>
    { return FunctionCall.of(ct.image, es.toArray(new Expression[es.size()]), source(ct, end)); }
}


BooleanExpression booleanExpressionTerm():
{BooleanExpression e; }
{
    ((<L_PAREN> e=shortCircuitingBooleanExpression() <R_PAREN> ) | e=functionCall() | e=variable() )
    {return e;}
}


Expression expression():
{ Expression e = null;}
{
    
    ( LOOKAHEAD(shortCircuitingBooleanExpression()) e=shortCircuitingBooleanExpression()| e = functionCall() |e = variable() | e=string() | e=number())
    { return e;}
}

Variable variable():
{ Token t; }
{
    t=<VARIABLE> { return Variable.of(t.image, source(t)); }
}



StringLiteral string():
{ Token t=null, e;}
{
    (
        <DOUBLE_QUOTE_STRING_LITERAL_START> (t=<DOUBLE_QUOTE_STRING_LITERAL>)? e=<DOUBLE_QUOTE_STRING_LITERAL_END>
      | <SINGLE_QUOTE_STRING_LITERAL_START> (t=<SINGLE_QUOTE_STRING_LITERAL>)? e=<SINGLE_QUOTE_STRING_LITERAL_END>
    )
    {return StringLiteral.of(t != null ? t.image : "", t != null ? source(t): source(e));}
}


NumberLiteral number():
{ Token t; }
{
    t=<NUMBER> { return NumberLiteral.of(Double.parseDouble(t.image.trim()), source(t)); }
}
